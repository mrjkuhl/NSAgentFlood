#!/usr/bin/env python2
#
# Copyright 2014 Joel Cool-Panama <mr.jkuhl@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import ctypes
from sdl2 import *
import ConfigParser
import time

def loadMapConf(confFile):

	filePointer = ConfigParser.RawConfigParser();
	filePointer.read(confFile);

	return filePointer;

def loadStage(renderer, stage):

	movementZoneList = readZoneList(stage);
	entityList = readEntityList(stage);

	image = SDL_LoadBMP(world + "resources/" + stage.get('stage', 'background'));
	background = SDL_CreateTextureFromSurface(renderer, image);
	SDL_FreeSurface(image);

	return background, movementZoneList, entityList;

def readEntityList(stage):

	entityList = [];
	tmpList = [];
	tmpDict = {};
	counter = 1;

	while True:

		try:

			entity = stage.get('stage', "entity" + str(counter));
			entity = entity.split(',');

			tmpList.append(entity);
			counter += 1;

		except:

			for entity in tmpList:

				tmpDict['x'] = int(entity[0]);
				tmpDict['y'] = int(entity[1]);
				tmpDict['health'] = int(entity[2]);
				tmpDict['atttimer'] = 0;
				tmpDict['mvttimer'] = 0;
				tmpDict['name'] = entity[3];
				tmpDict['sprite'] = entity[4];

				entityList.append(tmpDict)

			return entityList;

def readZoneList(stage):

	zoneList = [];
	counter = 1;

	while True:

		try:

			zone = stage.get('stage', "movementZone" + str(counter));
			zoneList.append(zone);
			counter += 1;

		except:

			return zoneList;

def testZone(movementZoneList, x, y):

	finalx = x + 40;
	finaly = y + 40;

	for movementZone in movementZoneList:

		movementZone = movementZone.split(',');
		movementZone = [int(num) for num in movementZone];

		if x >= movementZone[0] and y >= movementZone[1] and finalx <= movementZone[2] and y >= movementZone[3] and finalx <= movementZone[4] and finaly <= movementZone[5] and x >= movementZone[6] and finaly <= movementZone[7]:

			return True;

	return False;

def setPlayerOrientation(renderer, orientation):

	if orientation == "left":

		image = SDL_LoadBMP(b"resources/playerLeft.bmp");

	else:

		image = SDL_LoadBMP(b"resources/playerRight.bmp");

	return SDL_CreateTextureFromSurface(renderer, image);

def detectTarget(range, orientation, destination, entityList):

	targetx = destination.x;
	targety = destination.y;

	if orientation == "left":

		targetx = destination.x - range;

	elif orientation == "right":

		targetx = destination.x + range;

	elif orientation == "up":

		targety = destination.y - range;

	elif orientation == "down":

		targety = destination.y + range;

	for entity in entityList:

		if entity['x'] == targetx and entity['y'] == targety:

			return entity;

	return False;

def run():

	SDL_Init(SDL_INIT_VIDEO);

	spriteSource = SDL_Rect(0, 0, spriteSize, spriteSize);
	destination = SDL_Rect(int(windowWidth / 2 - spriteSize / 2), int(windowHeight / 2 - spriteSize / 2), spriteSize, spriteSize);

	window = SDL_CreateWindow(b"NSAgent Flood", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 600, SDL_WINDOW_SHOWN);
	renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

	windowsurface = SDL_GetWindowSurface(window);

	stage = loadMapConf(world + "level1/stages/stage1.conf");
	background, movementZoneList, entityList = loadStage(renderer, stage);

	playerEntity = {'health': 10, 'orientation': "left"}
	player = setPlayerOrientation(renderer, playerEntity['orientation']);

	gameRun = True;
	event = SDL_Event();

	while gameRun:

		SDL_RenderCopy(renderer, background, None, None);

		for entity in entityList:

			src = SDL_Rect(0, 0, spriteSize, spriteSize);
			dst = SDL_Rect(entity['x'], entity['y'], spriteSize, spriteSize);
			image = SDL_LoadBMP(world + "resources/" + entity['sprite']);
			sprite = SDL_CreateTextureFromSurface(renderer, image);
			SDL_FreeSurface(image);

			SDL_RenderCopy(renderer, sprite, src, dst);

		SDL_RenderCopy(renderer, player, spriteSource, destination);

		SDL_RenderPresent(renderer);

		SDL_WaitEvent(ctypes.byref(event))

		if event.type == SDL_QUIT:

			gameRun = False;

			break;

		elif event.type == SDL_KEYDOWN:

			keyPressed = event.key.keysym.sym;
			if keyPressed == moveUpKey:

				if destination.y <= 0:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageUp')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					destination.y = 560;
					continue;

				if testZone(movementZoneList, destination.x, destination.y - stepSize):

					destination.y -= stepSize;

			elif keyPressed == moveDownKey:

				if destination.y + spriteSize >= 600:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageDown')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					destination.y = 0;
					continue;

				if testZone(movementZoneList, destination.x, destination.y + stepSize):

					destination.y += stepSize;

			elif keyPressed == moveLeftKey: 

				playerEntity['orientation'] = "left";
				player = setPlayerOrientation(renderer, playerEntity['orientation']);

				if destination.x <= 0:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageLeft')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					destination.x = 760;
					continue;

				if testZone(movementZoneList, destination.x - stepSize, destination.y):

					destination.x -= stepSize;

			elif keyPressed == moveRightKey:

				playerEntity['orientation'] = "right";
				player = setPlayerOrientation(renderer, playerEntity['orientation']);

				if destination.x + spriteSize >= 800:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageRight')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					destination.x = 0;
					continue;

				if testZone(movementZoneList, destination.x + stepSize, destination.y):

					destination.x += stepSize;

			elif keyPressed == punchKey:

				effectedEntity = detectTarget(spriteSize, playerEntity['orientation'], destination, entityList)
				if effectedEntity:

					print "You punched!";
					if effectedEntity['health'] == 1:

						entityList.remove(effectedEntity);
						print "You slew " + effectedEntity['name'] + "!";
						continue;

					effectedEntity['health'] -= 1

			elif keyPressed == kickKey:

				effectedEntity = detectTarget(spriteSize, playerEntity['orientation'], destination, entityList)
				if effectedEntity:

					print "You kicked!";
					if effectedEntity['health'] == 1:

						entityList.remove(effectedEntity);
						print "You slew " + effectedEntity['name'] + "!";
						continue;

					effectedEntity['health'] -= 1

			elif keyPressed == SDLK_ESCAPE:

				gameRun = 0;

				break;

		for entity in entityList:

			if time.time() > entity['atttimer'] + .5 and (entity['x'] == destination.x + spriteSize or entity['x'] == destination.x - spriteSize) and entity['y'] == destination.y:

				if playerEntity['health'] == 1:

					print "You died."
					return;

				entity['atttimer'] = time.time();
				playerEntity['health'] -= 1;

				print entity['name'] + "hit you!";

			elif time.time() > entity['mvttimer'] + .2:

				entity['mvttimer'] = time.time();

				if entity['x'] > destination.x + spriteSize and entity['x'] != destination.x - spriteSize:

					entity['x'] -= stepSize;

				elif entity['x'] < destination.x + spriteSize and entity['x'] != destination.x - spriteSize:

					entity['x'] += stepSize;

				elif entity['y'] > destination.y:

					entity['y'] -= stepSize;

				elif entity['y'] < destination.y:

					entity['y'] += stepSize;

	SDL_DestroyWindow(window);
	SDL_Quit();

	return 0;

if __name__ == "__main__":

	spriteSize = 40;
	stepSize = int(spriteSize / 2);
	windowWidth = 800;
	windowHeight = 600;

	moveUpKey = SDLK_e;
	moveDownKey = SDLK_d;
	moveLeftKey = SDLK_s;
	moveRightKey = SDLK_f;
	punchKey = SDLK_t;
	kickKey = SDLK_g;

	world = "./worlds/nsagentflood/"

	sys.exit(run());
