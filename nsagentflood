#!/usr/bin/env python2
#
# Copyright 2014 Joel Cool-Panama <mr.jkuhl@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import ctypes
from sdl2 import *

import classes
import classes.player
import classes.spriteresources
from classes.movementzonelist import MovementZoneList
from classes.directionsresource import DirectionsResource

import ConfigParser
import importlib
import time

def loadMapConf(confFile):

	filePointer = ConfigParser.RawConfigParser();
	filePointer.read(confFile);

	return filePointer;

def loadStage(renderer, stage):

	movementZoneList = MovementZoneList(stage);
	entityList = readEntityList(stage);

	image = SDL_LoadBMP(world + "resources/" + stage.get('stage', 'background'));
	background = SDL_CreateTextureFromSurface(renderer, image);
	SDL_FreeSurface(image);

	return background, movementZoneList, entityList;

def readEntityList(stage):

	entityList = [];
	mobTypes = {};
	counter = 1;

	sys.path.append(world);

	while True:

		try:

			entityValues = stage.get('stage', "entity" + str(counter));
			entityValues = entityValues.split(',');

			entityClass = entityValues[9];
			entityValues.remove(entityClass);
			classObject = importlib.import_module(b"entities." + entityValues[8]);
			entityClass = getattr(classObject, entityClass);

			if entityValues[8] not in mobTypes:

				mobTypes[entityValues[8]] = classes.spriteresources.SpriteResources(world, entityValues[8]);

			spriteResource = mobTypes[entityValues[8]];

			entityList = addEntity(entityClass, entityValues, spriteResource, entityList);

			counter += 1;

		except:

			return entityList;

def addEntity(entityClass, entityValues, spriteResource, entityList):

	entityList.append(entityClass(entityValues, spriteResource));

	return entityList;

def detectTarget(range, orientation, destination, entityList):

	targetx = destination.x;
	targety = destination.y;

	if orientation == DirectionsResource.left:

		targetx = destination.x - range;

	elif orientation == DirectionsResource.right:

		targetx = destination.x + range;

	elif orientation == "up":

		targety = destination.y - range;

	elif orientation == "down":

		targety = destination.y + range;

	for object in entityList:

		if object.x == targetx and object.y == targety:

			return object;

	return False;

def run():

	SDL_Init(SDL_INIT_VIDEO);

	window = SDL_CreateWindow(b"NSAgent Flood", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 600, SDL_WINDOW_SHOWN);
	renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

	windowsurface = SDL_GetWindowSurface(window);

	stage = loadMapConf(world + "level1/stages/stage1.conf");
	background, movementZoneList, entityList = loadStage(renderer, stage);

	src = SDL_Rect(0, 0, spriteSize, spriteSize);

	playerValues = [int(windowWidth / 2 - spriteSize /2), int(windowHeight / 2 - spriteSize / 2), 10, DirectionsResource.left, .3, .1, 0, 0, "player"];
	player = classes.player.Player(playerValues, classes.spriteresources.SpriteResources("", "player"));

	gameRun = True;
	event = SDL_Event();

	while gameRun:

		SDL_RenderCopy(renderer, background, None, None);

		for object in entityList:

			sprite = SDL_CreateTextureFromSurface(renderer, object.sprite);

			SDL_RenderCopy(renderer, sprite, src, object.destination);

		sprite = SDL_CreateTextureFromSurface(renderer, player.sprite);
		SDL_RenderCopy(renderer, sprite, src, player.destination);

		SDL_RenderPresent(renderer);

		SDL_PollEvent(ctypes.byref(event))

		if event.type == SDL_QUIT:

			gameRun = False;

			break;

		elif event.type == SDL_KEYDOWN:

			keyPressed = event.key.keysym.sym;
			if keyPressed == moveUpKey and time.time() > player.mvttimer + player.mvtinterval:

				player.mvttimer = time.time();

				if player.y <= 0:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageUp')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					player.setYCoord(560, movementZoneList);
					continue;

				player.setYCoord(player.y - stepSize, movementZoneList);

			elif keyPressed == moveDownKey and time.time() > player.mvttimer + player.mvtinterval:

				player.mvttimer = time.time();

				if player.y + spriteSize >= 600:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageDown')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					player.setYCoord(0, movementZoneList);
					continue;

				player.setYCoord(player.y + stepSize, movementZoneList);

			elif keyPressed == moveLeftKey and time.time() > player.mvttimer + player.mvtinterval: 

				player.mvttimer = time.time();
				player.setOrientation(DirectionsResource.left);

				if player.x <= 0:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageLeft')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					player.setXCoord(760, movementZoneList);
					continue;

				player.setXCoord(player.x - stepSize, movementZoneList);

			elif keyPressed == moveRightKey and time.time() > player.mvttimer + player.mvtinterval:

				player.mvttimer = time.time();
				player.setOrientation(DirectionsResource.right);

				if player.x + spriteSize >= 800:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageRight')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					player.setXCoord(0, movementZoneList);
					continue;

				player.setXCoord(player.x + stepSize, movementZoneList);

			elif keyPressed == punchKey:

				effectedEntity = detectTarget(spriteSize, player.orientation, player.destination, entityList)
				if effectedEntity and time.time() > player.atttimer + player.attinterval:

					player.atttimer = time.time();
					print "You punched!";

					if effectedEntity.health == 1:

						entityList.remove(effectedEntity);
						print "You slew " + effectedEntity.name + "!";
						continue;

					effectedEntity.health -= 1

			elif keyPressed == kickKey:

				effectedEntity = detectTarget(spriteSize, player.orientation, player.destination, entityList)
				if effectedEntity and time.time() > player.atttimer + player.attinterval:

					player.atttimer = time.time();
					print "You kicked!";

					if effectedEntity.health == 1:

						entityList.remove(effectedEntity);
						print "You slew " + effectedEntity.name + "!";
						continue;

					effectedEntity.health -= 1

			elif keyPressed == SDLK_ESCAPE:

				gameRun = 0;

				break;

		for object in entityList:

			object.entityAI(player, movementZoneList);

	SDL_DestroyWindow(window);
	SDL_Quit();

	return 0;

if __name__ == "__main__":

	spriteSize = 40;
	stepSize = int(spriteSize / 2);
	windowWidth = 800;
	windowHeight = 600;

	moveUpKey = SDLK_e;
	moveDownKey = SDLK_d;
	moveLeftKey = SDLK_s;
	moveRightKey = SDLK_f;
	punchKey = SDLK_t;
	kickKey = SDLK_g;

	world = "worlds/nsagentflood/"

	sys.exit(run());
