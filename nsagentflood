#!/usr/bin/env python2
#
# Copyright 2014 Joel Cool-Panama <mr.jkuhl@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import ctypes
from sdl2 import *

import classes
import classes.player
import classes.spriteresources
from classes.world import World
from classes.entitylist import EntityList
from classes.movementzonelist import MovementZoneList
from classes.directionsresource import DirectionsResource

import ConfigParser
import importlib
import time

def detectTarget(range, orientation, destination, entityList):

	targetx = destination.x;
	targety = destination.y;

	if orientation == DirectionsResource.left:

		targetx = destination.x - range;

	elif orientation == DirectionsResource.right:

		targetx = destination.x + range;

	elif orientation == "up":

		targety = destination.y - range;

	elif orientation == "down":

		targety = destination.y + range;

	for object in entityList.entityList:

		if object.x == targetx and object.y == targety:

			return object;

	return False;

def run():

	SDL_Init(SDL_INIT_VIDEO);

	window = SDL_CreateWindow(b"NSAgent Flood", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 600, SDL_WINDOW_SHOWN);
	renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

	windowsurface = SDL_GetWindowSurface(window);

	worldObj = World(worldPath, renderer);

	src = SDL_Rect(0, 0, spriteSize, spriteSize);

	playerValues = [int(windowWidth / 2 - spriteSize /2), int(windowHeight / 2 - spriteSize / 2), 10, DirectionsResource.left, .3, .1, 0, 0, "player"];
	player = classes.player.Player(playerValues, classes.spriteresources.SpriteResources("", "player"));

	gameRun = True;
	event = SDL_Event();

	while gameRun:

		SDL_RenderCopy(renderer, worldObj.background, None, None);

		for object in worldObj.entityList.entityList:

			sprite = SDL_CreateTextureFromSurface(renderer, object.sprite);

			SDL_RenderCopy(renderer, sprite, src, object.destination);

		sprite = SDL_CreateTextureFromSurface(renderer, player.sprite);
		SDL_RenderCopy(renderer, sprite, src, player.destination);

		SDL_RenderPresent(renderer);

		SDL_PollEvent(ctypes.byref(event))

		if event.type == SDL_QUIT:

			gameRun = False;

			break;

		elif event.type == SDL_KEYDOWN:

			keyPressed = event.key.keysym.sym;
			if keyPressed == moveUpKey and time.time() > player.mvttimer + player.mvtinterval:

				player.mvttimer = time.time();

				if player.y <= 0:

					worldObj.gotoNextStage("up");
					player.setYCoord(560, worldObj.movementZoneList);
					continue;

				player.setYCoord(player.y - stepSize, worldObj.movementZoneList);

			elif keyPressed == moveDownKey and time.time() > player.mvttimer + player.mvtinterval:

				player.mvttimer = time.time();

				if player.y + spriteSize >= 600:

					worldObj.gotoNextStage("down");
					player.setYCoord(0, worldObj.movementZoneList);
					continue;

				player.setYCoord(player.y + stepSize, worldObj.movementZoneList);

			elif keyPressed == moveLeftKey and time.time() > player.mvttimer + player.mvtinterval: 

				player.mvttimer = time.time();
				player.setOrientation(DirectionsResource.left);

				if player.x <= 0:

					worldObj.gotoNextStage("left");
					player.setXCoord(760, worldObj.movementZoneList);
					continue;

				player.setXCoord(player.x - stepSize, worldObj.movementZoneList);

			elif keyPressed == moveRightKey and time.time() > player.mvttimer + player.mvtinterval:

				player.mvttimer = time.time();
				player.setOrientation(DirectionsResource.right);

				if player.x + spriteSize >= 800:

					worldObj.gotoNextStage("right");
					player.setXCoord(0, worldObj.movementZoneList);
					continue;

				player.setXCoord(player.x + stepSize, worldObj.movementZoneList);

			elif keyPressed == punchKey:

				effectedEntity = detectTarget(spriteSize, player.orientation, player.destination, worldObj.entityList)
				if effectedEntity and time.time() > player.atttimer + player.attinterval:

					player.atttimer = time.time();
					print "You punched!";

					if effectedEntity.health == 1:

						worldObj.entityList.removeEntity(effectedEntity);
						print "You slew " + effectedEntity.name + "!";
						continue;

					effectedEntity.health -= 1

			elif keyPressed == kickKey:

				effectedEntity = detectTarget(spriteSize, player.orientation, player.destination, worldObj.entityList)
				if effectedEntity and time.time() > player.atttimer + player.attinterval:

					player.atttimer = time.time();
					print "You kicked!";

					if effectedEntity.health == 1:

						worldObj.entityList.removeEntity(effectedEntity);
						print "You slew " + effectedEntity.name + "!";
						continue;

					effectedEntity.health -= 1

			elif keyPressed == SDLK_ESCAPE:

				gameRun = 0;

				break;

		for object in worldObj.entityList.entityList:

			object.entityAI(player, worldObj.movementZoneList);

	SDL_DestroyWindow(window);
	SDL_Quit();

	return 0;

if __name__ == "__main__":

	spriteSize = 40;
	stepSize = int(spriteSize / 2);
	windowWidth = 800;
	windowHeight = 600;

	moveUpKey = SDLK_e;
	moveDownKey = SDLK_d;
	moveLeftKey = SDLK_s;
	moveRightKey = SDLK_f;
	punchKey = SDLK_t;
	kickKey = SDLK_g;

	worldPath = "worlds/nsagentflood/"

	sys.exit(run());
