#!/usr/bin/env python2
#
# Copyright 2014 Joel Cool-Panama <mr.jkuhl@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import ctypes
from sdl2 import *
import ConfigParser
import time

class entity():

	def __init__(self, entityValues):

		self.x = int(entityValues[0]);
		self.y = int(entityValues[1]);
		self.health = int(entityValues[2]);
		self.orientation = entityValues[3];
		self.attinterval = float(entityValues[4]);
		self.mvtinterval = float(entityValues[5]);
		self.atttimer = int(entityValues[6]);
		self.mvttimer = int(entityValues[7]);
		self.name = entityValues[8];

		self.sprite = "";
		self.destination = SDL_Rect(self.x, self.y, spriteSize, spriteSize);
		self.updateSprite();

	def setOrientation(self, newOrientation):

		self.orientation = newOrientation;

		self.updateSprite();

	def setXCoord(self, newXCoord, movementZoneList):

		if self.testZone(movementZoneList, newXCoord, self.y):

			self.x = newXCoord;

			self.updateDestination();

	def setYCoord(self, newYCoord, movementZoneList):

		if self.testZone(movementZoneList, self.x, newYCoord):

			self.y = newYCoord

			self.updateDestination();

	def updateDestination(self):

		self.destination = SDL_Rect(self.x, self.y, spriteSize, spriteSize);
	def updateSprite(self):

		if self.orientation == "left":

			self.sprite = SDL_LoadBMP(b"resources/" + self.name + "Left.bmp");

		else:

			self.sprite = SDL_LoadBMP(b"resources/" + self.name + "Right.bmp");

	def testZone(self, movementZoneList, newXCoord, newYCoord):

		finalx = newXCoord + spriteSize;
		finaly = newYCoord + spriteSize;

		for movementZone in movementZoneList:

			movementZone = movementZone.split(',');
			movementZone = [int(num) for num in movementZone];

			if newXCoord >= movementZone[0] and newYCoord >= movementZone[1] and finalx <= movementZone[2] and newYCoord >= movementZone[3] and finalx <= movementZone[4] and finaly <= movementZone[5] and newXCoord >= movementZone[6] and finaly <= movementZone[7]:

				return True;

		return False;

def loadMapConf(confFile):

	filePointer = ConfigParser.RawConfigParser();
	filePointer.read(confFile);

	return filePointer;

def loadStage(renderer, stage):

	movementZoneList = readZoneList(stage);
	entityList = readEntityList(stage);

	image = SDL_LoadBMP(world + "resources/" + stage.get('stage', 'background'));
	background = SDL_CreateTextureFromSurface(renderer, image);
	SDL_FreeSurface(image);

	return background, movementZoneList, entityList;

def readEntityList(stage):

	entityList = [];
	counter = 1;

	while True:

		try:

			entityValues = stage.get('stage', "entity" + str(counter));
			entityValues = entityValues.split(',');

			entityList = addEntity(entityValues, entityList);

			counter += 1;

		except:

			return entityList;

def addEntity(entityValues, entityList):

	entityList.append(entity(entityValues));

	return entityList;

def readZoneList(stage):

	zoneList = [];
	counter = 1;

	while True:

		try:

			zone = stage.get('stage', "movementZone" + str(counter));
			zoneList.append(zone);
			counter += 1;

		except:

			return zoneList;

def detectTarget(range, orientation, destination, entityList):

	targetx = destination.x;
	targety = destination.y;

	if orientation == "left":

		targetx = destination.x - range;

	elif orientation == "right":

		targetx = destination.x + range;

	elif orientation == "up":

		targety = destination.y - range;

	elif orientation == "down":

		targety = destination.y + range;

	for object in entityList:

		if object.x == targetx and object.y == targety:

			return object;

	return False;

def run():

	SDL_Init(SDL_INIT_VIDEO);

	window = SDL_CreateWindow(b"NSAgent Flood", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 800, 600, SDL_WINDOW_SHOWN);
	renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);

	windowsurface = SDL_GetWindowSurface(window);

	stage = loadMapConf(world + "level1/stages/stage1.conf");
	background, movementZoneList, entityList = loadStage(renderer, stage);

	src = SDL_Rect(0, 0, spriteSize, spriteSize);

	playerValues = [int(windowWidth / 2 - spriteSize /2), int(windowHeight / 2 - spriteSize / 2), 10, "left", .3, .1, 0, 0, "player"];
	player = entity(playerValues);

	gameRun = True;
	event = SDL_Event();

	while gameRun:

		SDL_RenderCopy(renderer, background, None, None);

		for object in entityList:

			sprite = SDL_CreateTextureFromSurface(renderer, object.sprite);

			SDL_RenderCopy(renderer, sprite, src, object.destination);

		sprite = SDL_CreateTextureFromSurface(renderer, player.sprite);
		SDL_RenderCopy(renderer, sprite, src, player.destination);

		SDL_RenderPresent(renderer);

		SDL_PollEvent(ctypes.byref(event))

		if event.type == SDL_QUIT:

			gameRun = False;

			break;

		elif event.type == SDL_KEYDOWN:

			keyPressed = event.key.keysym.sym;
			if keyPressed == moveUpKey and time.time() > player.mvttimer + player.mvtinterval:

				player.mvttimer = time.time();

				if player.y <= 0:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageUp')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					player.setYCoord(560, movementZoneList);
					continue;

				player.setYCoord(player.y - stepSize, movementZoneList);

			elif keyPressed == moveDownKey and time.time() > player.mvttimer + player.mvtinterval:

				player.mvttimer = time.time();

				if player.y + spriteSize >= 600:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageDown')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					player.setYCoord(0, movementZoneList);
					continue;

				player.setYCoord(player.y + stepSize, movementZoneList);

			elif keyPressed == moveLeftKey and time.time() > player.mvttimer + player.mvtinterval: 

				player.mvttimer = time.time();
				player.setOrientation("left");

				if player.x <= 0:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageLeft')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					player.setXCoord(760, movementZoneList);
					continue;

				player.setXCoord(player.x - stepSize, movementZoneList);

			elif keyPressed == moveRightKey and time.time() > player.mvttimer + player.mvtinterval:

				player.mvttimer = time.time();
				player.setOrientation("right");

				if player.x + spriteSize >= 800:

					stage = loadMapConf(world + "level1/stages/" + stage.get('stage', 'stageRight')  + ".conf");
					background, movementZoneList, entityList = loadStage(renderer, stage);
					player.setXCoord(0, movementZoneList);
					continue;

				player.setXCoord(player.x + stepSize, movementZoneList);

			elif keyPressed == punchKey:

				effectedEntity = detectTarget(spriteSize, player.orientation, player.destination, entityList)
				if effectedEntity and time.time() > player.atttimer + player.attinterval:

					player.atttimer = time.time();
					print "You punched!";

					if effectedEntity.health == 1:

						entityList.remove(effectedEntity);
						print "You slew " + effectedEntity.name + "!";
						continue;

					effectedEntity.health -= 1

			elif keyPressed == kickKey:

				effectedEntity = detectTarget(spriteSize, player.orientation, player.destination, entityList)
				if effectedEntity and time.time() > player.atttimer + player.attinterval:

					player.atttimer = time.time();
					print "You kicked!";

					if effectedEntity.health == 1:

						entityList.remove(effectedEntity);
						print "You slew " + effectedEntity.name + "!";
						continue;

					effectedEntity.health -= 1

			elif keyPressed == SDLK_ESCAPE:

				gameRun = 0;

				break;

		for object in entityList:

			if time.time() > object.atttimer + object.attinterval and (object.x == player.x + spriteSize or object.x == player.x - spriteSize) and object.y == player.y:

				print object.name + " hit you!";

				if player.health == 1:

					print "You died."
					return;

				object.atttimer = time.time();
				player.health -= 1;

			elif time.time() > object.mvttimer + object.mvtinterval:

				object.mvttimer = time.time();

				if object.x > player.x + spriteSize and object.x != player.x - spriteSize:

					object.setOrientation("left");
					object.setXCoord(object.x - stepSize, movementZoneList);

				elif object.x < player.x + spriteSize and object.x != player.x - spriteSize:

					object.setOrientation("right");
					object.setXCoord(object.x + stepSize, movementZoneList);

				elif object.y > player.y:

					object.setYCoord(object.y - stepSize, movementZoneList);

				elif object.y < player.y:

					object.setYCoord(object.y + stepSize, movementZoneList);

	SDL_DestroyWindow(window);
	SDL_Quit();

	return 0;

if __name__ == "__main__":

	spriteSize = 40;
	stepSize = int(spriteSize / 2);
	windowWidth = 800;
	windowHeight = 600;

	moveUpKey = SDLK_e;
	moveDownKey = SDLK_d;
	moveLeftKey = SDLK_s;
	moveRightKey = SDLK_f;
	punchKey = SDLK_t;
	kickKey = SDLK_g;

	world = "./worlds/nsagentflood/"

	sys.exit(run());
